# 软件设计原则与分层

## 设计原则
### 单一职责原则
* 永远不应该有多余一个的原因来改变某个类或者方法。
* 理解：对于一个类来说，应该有且之后一个引起它变化的原因。
* 应用：如果一个类拥有了两种职责，那就可以将这个类分成两个类。

### 开放封闭原则
* 软件实体扩展应该是开放的，但对于修改应该是封闭的。
* 理解：对扩展开放、对修改封闭。可以去扩展类、但不要去修改类。
* 应用：当需求有改动，精良用继承或者组合的方式来扩展类的功能，而不是直接修改类的代码。

### 里氏替换原则
* 理解：父类应用的地方一定能够被子类替换
* 面向对象的时候要注意，但是函数式编程关注不高。

### 最少知识原则
* 只与你最直接的对象交流
* 理解：高内聚、低耦合
* 应用：做系统设计时，尽量减少依赖关系

### 接口隔离原则
* 不应强迫类依赖于它不需要的接口内容。
* 理解：不要对外暴露没有实际意义的接口。用户不应该依赖它不需要的接口。
* 应用：当需要对外暴露接口时，如果是非必要对外提供，尽量删除。

### 依赖倒置原则
* 高层模块不应该依赖于低层模块，所有模块都应该依赖于抽象。抽象不应该依赖于细节，而是细节应该依赖于抽象。
* 理解：应该面向接口编程，不应该面向实现类编程。
* 并不是说，所有累都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程。

### SOLID
将以上六大原则，除了最少只是原则外，其他五个的英文首字母拼接在一起就是SOLID（稳定的），所以也称之为SOLID原则

除了以上原则之外，还有一些其他原则需要注意：

### 组合/聚合复用原则
* 扩展类的功能的时候，组合由于继承
* 原因：组合灵活性更高
* 在23种经典设计模式中频繁使用，如代理模式、装饰器模式、适配器模式等。

### 无环依赖原则
* 模块A依赖于B，B依赖于C，C又依赖于A，此时将出现循环依赖
* 如果出现这种问题，可通过「中介者模式」解决。
  * 注册一个中介者对象，比如这里叫Mediator，作为A、B、C之间的中间人，协调三者的通信，三个对象都将Mediator注入，并将自身的消息通过Mediator进行传递。

### 共同封装原则
* 应该将易变的类放在一个包中，将变化隔离出来。
* 基于「开放-封闭原则」诞生的原则

### 共用重用原则
* 如果重用了包中的一个类，那么也就相当于重用了包中的所有类，我们要尽可能减小包的大小

### 好莱坞原则
* Don't call me, I'll call you.
* 「控制反转」（或称为「依赖注入」）
* 不需要主动创建对象，而是使用容器或者其他的工具帮我们来创建并管理这些对象

### 不重复原则
* 不要让重复的代码到处都是，尽可能封装

### 保持简单与傻瓜
* 保持系统界面简洁，功能使用，操作方便

### 高内聚低耦合原则
* 模块或方法内部的基础功能高度内聚，模块与模块或方法与方法之间的耦合度低。
* 高内聚低耦合有助于提高代码的可重用性和可维护性。

### 你不需要它
* 不要一开始就把系统设计地非常复杂，不要陷入「过度设计」的深渊。
* 让系统足够简单，而又不失扩展性

## 软件架构
软件架构分为：
* 系统级架构
* 应用级架构
* 模块级架构
* 代码级架构

### 系统级架构
* 应用在整个系统内，如何与后端服务进行通信，与第三方系统如何集成
* 设计的前提条件：链接前端系统与其他系统之间的关系。
* 关系包括：业务关系和协作机制。
* 前端与后端的关系考虑的主要因素是：前后端分离的架构设计。包括：
  * 技术实施
  * API接口管理
  * 用户鉴权
  * API文档管理
  * Mock使用
  * BFF
  * 是否需要SSR
  * ....
* 微前端
  * 在一个系统内，微前端是应用间的架构方案。
  * 在多个系统间，微前端是一种系统间的架构方案。
  * 微前端是将多个前端应用以某种形式结合在一起进行应用。
  * 旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个局势应用（Frontend Monolith）后，随之而来的应用难以维护，不理拓展问题。
  * 实现形式：
    * 单实例：
      * 即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。
      * 通常基于url的辩护来做子应用的切换
    * 多实例：
      * 同一时刻可展示多个子应用
      * 通常使用Web Components 方案来做子应用的封装，子应用更像是一个业务组件而不是独立应用。
  
  